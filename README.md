## معماری هسته

سیستم خود را در این لایه‌های اصلی تصور کنید:

1. **لایه نمایش (GUI و ورودی کیبورد):** این چیزی است که اپراتور انسانی می‌بیند و با آن تعامل دارد.
2. **لایه رابط تیم هوش مصنوعی:** یک کتابخانه پایتون که یک رابط تمیز و برنامه‌نویسی شده برای تیم هوش مصنوعی جهت کنترل و نظارت بر ROV فراهم می‌کند.
3. **لایه دامنه (وضعیت و کنترل ربات):** این لایه خود ربات را نشان می‌دهد - وضعیت فعلی آن، قابلیت‌ها و توابع سطح پایین برای کنترل سخت‌افزار آن.
4. **لایه زیرساخت (ارتباطات سخت‌افزاری):** این لایه به جزئیات ارتباط با موتورها، سنسورهای ROV می‌پردازد.

نحوه تعامل این لایه‌ها به شکل زیر است:

```
+-------------------------+      +-------------------------+
|رابط کاربری گرافیکی (GUI)|      |      تیم هوش مصنوعی     |
+-------------------------+      +-------------------------+
              |                              |
              |                              |
              V                              |
+-------------------------+                  |             +--------------------+
|       پردازش دستور      |--------------------------------l     پردازش زبان    |
|     استاندارد Mavlink   |                                |                    |
+-------------------------+                                +--------------------+
              |
              V
+-------------------------+
|      منطق کنترل ربات    |
|   (مدیریت وضعیت،        |
|     پردازش دستورها)     |
+-------------------------+
              |
              V
+-------------------------+
|   لایه انتزاعی سخت‌افزار  |
|         (HAL)           |
+-------------------------+
              |
              V
+-------------------------+
|      سخت‌افزار ROV       |
|     (موتورها، سنسورها)  |
+-------------------------+
```

-----

## سازماندهی کد (ساختار پوشه‌ها)

یک ساختار پروژه ممکن می‌تواند به شکل زیر باشد:

```
rov_controller/
├── ai_interface/            # کتابخانه رابط تیم هوش مصنوعی
│   ├── __init__.py          # خروجی‌های رابط عمومی
│   ├── controller.py        # کلاس اصلی ROVController
│   ├── types.py             # انواع داده و ساختارها
│   └── events.py            # سیستم مدیریت رویدادها
├── robot_core/              # منطق هسته ربات
│   ├── robot.py             # کلاس اصلی ربات، مدیریت وضعیت
│   ├── control.py           # توابع کنترل حرکت و بازوها
│   ├── telemetry.py         # مدیریت داده‌های سنسورها
│   └── command_processor.py # پردازش دستورات از GUI/API
├── hardware_interface/      # ارتباط با سخت‌افزار واقعی
│   ├── motors.py
│   ├── sensors.py
│   ├── camera.py
│   └── communication.py     # ارتباط سریال، UDP و غیره
├── common/                  # ابزارهای مشترک، ثابت‌ها
│   ├── utils.py
│   └── config.py            # تنظیمات پیکربندی
├── tests/                   # تست‌های واحد و یکپارچه‌سازی
│   ├── test_api.py
│   ├── test_robot_core.py
│   └── ...
├── main.py                  # نقطه ورود اصلی برنامه
└── README.md
└── requirements.txt
```

-----

## اجزای کلیدی و عملکرد

### ۱. رابط تیم هوش مصنوعی (`ai_interface/`)

  * **هدف:** فراهم کردن یک رابط تمیز و برنامه‌نویسی شده برای تیم هوش مصنوعی جهت کنترل و نظارت بر ROV.
  * **اجزای اصلی:**
      * **کلاس ROVController:** رابط اصلی برای کنترل ROV
          * متدهای حرکت: `move(x, y, z, yaw)`، `set_camera_angle(pan, tilt)`
          * دسترسی به وضعیت: پراپرتی‌ها برای عمق فعلی، جهت‌گیری، خوانش سنسورها
          * پیکربندی: متدهایی برای تنظیم پارامترهای کنترل
      * **سیستم رویداد (Event System):** کال‌بک‌ها برای به‌روزرسانی سنسورها، فریم‌های دوربین، تغییرات وضعیت
      * **انواع داده:** کلاس‌های به خوبی تعریف شده برای داده‌های سنسور، فریم‌های دوربین، وضعیت ربات
  * **ویژگی‌ها:**
      * عملیات امن در محیط چند نخی (Thread-safe)
      * پشتیبانی از `async` برای مدیریت رویدادها
      * مدیریت جامع خطا
      * راهنمای نوع (Type hints) و مستندات
  * **مثال استفاده:**

<!-- end list -->

```python
from rov_controller import ROVController, SensorData

# مقداردهی اولیه کنترلر
rov = ROVController()

# متدهای کنترل
rov.move(x=0.5, y=0.0, z=0.0, yaw=0.0)
rov.set_camera_angle(pan=30, tilt=45)

# دسترسی به وضعیت
depth = rov.state.depth
orientation = rov.state.orientation

# مدیریت رویداد
@rov.on_sensor_update
def handle_sensor_update(sensor_data: SensorData):
    process_sensor_data(sensor_data)
```

### ۲. هسته ربات (`robot_core/`)

  * **کلاس `Robot` (`robot.py`):**
      * وضعیت کلی ROV را مدیریت می‌کند (مانند `current_speed`, `orientation`, `armed_status`, `camera_angle`).
      * متدهای سطح بالایی مانند `move(x, y, z, yaw)`، `set_camera_angle(pan, tilt)`، `get_sensor_data()` را فراهم می‌کند.
      * این متدها به صورت داخلی توابع مناسب در `لایه انتزاعی سخت‌افزار` را فراخوانی می‌کنند.
  * **ماژول `Control` (`control.py`):**
      * منطق دقیق‌تر برای ترجمه حرکات مورد نظر به دستورات موتور (مثلاً محاسبه مقادیر تراسترها برای یک جهت و سرعت معین).
  * **ماژول `Telemetry` (`telemetry.py`):**
      * وظیفه جمع‌آوری، پردازش و بسته‌بندی داده‌ها از سنسورهای مختلف را بر عهده دارد.
  * **پردازشگر دستور (`command_processor.py`):**
      * نقطه مرکزی برای دریافت دستورات از *همه* منابع (GUI، کیبورد، API).
      * اطمینان حاصل می‌کند که دستورات معتبر هستند و در صورت لزوم آن‌ها را اولویت‌بندی می‌کند (مثلاً یک دستور توقف دستی از GUI ممکن است یک دستور هوش مصنوعی را لغو کند).
      * متدهای کلاس `Robot` یا ماژول `Control` را فراخوانی می‌کند.

### ۳. لایه انتزاعی سخت‌افزار (HAL) (`hardware_interface/`)

  * **هدف:** جداسازی بقیه برنامه از جزئیات نحوه صحبت با سخت‌افزار. اگر یک کنترلر موتور را تغییر دهید، فقط باید این لایه را به‌روز کنید.
  * **ماژول‌ها:**
      * `motors.py`: توابعی برای تنظیم سرعت و جهت هر تراستر/موتور.
      * `sensors.py`: توابعی برای خواندن داده‌ها از IMUها، سنسورهای عمق و غیره.
      * `camera.py`: توابعی برای مقداردهی اولیه دوربین، گرفتن فریم‌ها و احتمالاً پخش ویدیو.
      * `communication.py`: مدیریت پروتکل‌های ارتباطی سطح پایین (مانند ارتباط پورت سریال با یک آردوینو، I2C، بسته‌های UDP).
  * **تعامل:** `هسته ربات` توابع موجود در HAL را برای تعامل با ROV فیزیکی فراخوانی می‌کند.

### ۴. ابزارهای مشترک (`common/`)

  * **`config.py`:** ذخیره ثابت‌ها، تنظیمات پین‌ها، آدرس‌های IP، مقادیر کالیبراسیون و غیره.
  * **`utils.py`:** توابع کمکی که در سراسر پروژه استفاده می‌شوند (مثلاً تبدیل داده‌ها، راه‌اندازی لاگ‌گیری).

-----

## مثال جریان داده: دستور هوش مصنوعی

1.  **تیم هوش مصنوعی:** از کتابخانه `ROVController` استفاده می‌کند:
    ```python
    rov.move(x=0.5, y=0.0, z=0.0, yaw=0.0)
    ```
2.  **لایه رابط هوش مصنوعی (`ai_interface/controller.py`):**
      * پارامترهای دستور را اعتبارسنجی می‌کند.
      * بررسی‌های ایمنی را انجام می‌دهد.
      * متد مناسب در هسته ربات را فراخوانی می‌کند.
3.  **پردازشگر دستور (`robot_core/command_processor.py`):**
      * دستور پردازش شده را دریافت می‌کند.
      * ممکن است بررسی‌های ایمنی یا اعتبارسنجی وضعیت را انجام دهد.
      * متد مربوطه را در `robot_core/robot.py` فراخوانی می‌کند، مثلاً `my_robot.move(forward=0.5)`.
4.  **کلاس ربات (`robot_core/robot.py`):**
      * متد `move()` تعیین می‌کند کدام تراسترها باید فعال شوند.
      * توابع موجود در `لایه انتزاعی سخت‌افزار` را فراخوانی می‌کند، مثلاً `hal.motors.set_thruster_speed(FRONT_LEFT, calculated_speed)`.
      * وضعیت داخلی خود را به‌روز می‌کند (مثلاً `self.current_velocity`).
5.  **لایه HAL (`hardware_interface/motors.py`):**
      * دستور `set_thruster_speed` را به سیگنال‌ها/دستورات واقعی برای کنترلر موتور ترجمه می‌کند (مثلاً در یک پورت سریال می‌نویسد یا یک سیگنال PWM ارسال می‌کند).
6.  **تله‌متری/به‌روزرسانی وضعیت (جریان معکوس):**
      * لایه HAL (`sensors.py`) به طور مداوم داده‌های سنسور را می‌خواند.
      * این داده‌ها توسط ماژول `Telemetry` (`telemetry.py`) پردازش شده و وضعیت کلاس `Robot` را به‌روز می‌کنند.
      * رابط کاربری گرافیکی (GUI) برای تازه‌سازی نمایش خود، در تغییرات وضعیت کلاس `Robot` مشترک می‌شود (یا کلاس `Robot` به‌روزرسانی‌ها را ارسال می‌کند).
      * اندپوینت `GET /robot/status` در لایه API، هنگام درخواست توسط هوش مصنوعی، وضعیت فعلی را از کلاس `Robot` می‌خواند.

-----

## ملاحظات کلیدی

  * **عملیات ناهمگام (Asynchronous):** برای مدیریت استریم‌های دوربین، دستورات همزمان و ورودی/خروجی سخت‌افزاری غیرمسدودکننده، استفاده از `asyncio` را در نظر بگیرید. این امر به ویژه برای پاسخگو ماندن API و GUI مهم است.
  * **مدیریت وضعیت:** به وضوح تعریف کنید که چگونه وضعیت ربات در بین اجزای مختلف مدیریت و همگام‌سازی می‌شود. یک کلاس مرکزی `Robot` اغلب رویکرد خوبی است.
  * **مدیریت خطا و لاگ‌گیری:** مدیریت خطای قوی و لاگ‌گیری را در سراسر برنامه پیاده‌سازی کنید.
  * **پیکربندی:** برنامه خود را از طریق فایل‌های پیکربندی یا متغیرهای محیطی قابل تنظیم کنید (مثلاً آدرس‌های IP، پورت‌ها، داده‌های کالیبراسیون).
  * **تست‌نویسی:** برای ماژول‌های جداگانه (به ویژه منطق هسته و HAL) تست‌های واحد و برای اندپوینت‌های API و جریان‌های دستور، تست‌های یکپارچه‌سازی بنویسید.
  * **ماژولار بودن برای تیم هوش مصنوعی:** API باید به خوبی مستند و پایدار باشد. تیم هوش مصنوعی فقط باید با این API تعامل داشته باشد و نگران جزئیات پیاده‌سازی داخلی کنترل ربات یا سخت‌افزار نباشد.
  * **امنیت در محیط چند نخی (Thread Safety):** هنگامی که چندین جزء هوش مصنوعی به طور همزمان به `ROVController` دسترسی دارند، از امن بودن عملیات اطمینان حاصل کنید.
  * **مستندات:** مستندات جامع و مثال‌هایی برای رابط تیم هوش مصنوعی فراهم کنید.
  * **کنترل نسخه:** برای اطمینان از سازگاری، نسخه‌بندی واضحی را برای رابط تیم هوش مصنوعی حفظ کنید.
  * **تست:** اسکریپت‌های نمونه و تست‌های یکپارچه‌سازی را به طور خاص برای استفاده تیم هوش مصنوعی بگنجانید.

این معماری یک پایه محکم برای ساخت یک کنترلر ROV قابل نگهداری و توسعه‌پذیر فراهم می‌کند. موفق باشید\!